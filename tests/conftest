import pytest
import pandas as pd
import re
import pytest
import asyncio
@pytest.fixture


def remove_whitespace(df):
  df = df.copy()
  columns_to_clean = df.select_dtypes(include=['object', 'string']).columns.tolist()
  df[columns_to_clean] = df[columns_to_clean].apply(lambda x: x.str.replace(" ", ""))
  return df

def normalize_date(df,column_name):
  df = df.copy()
  for idx in df.index:
    if (validate_date_format(df.loc[idx,column_name])[1] == True):
      if isinstance(df.loc[idx,column_name], str):
        day, month, year = df.loc[idx,column_name].split('/')
        df.loc[idx,column_name] = f"{year}-{month}-{day}"
  return df

def invalid_currency(df,column_name):
  df = df.copy()
  for idx in df.index:
    if currency_val(df.loc[idx,"column_name"]) == False:
      df.loc[idx,"column_name"] = None
  return df

def replace_missing_with_none(df, columns):
    """
    Replace missing values (NaN, NaT, None, etc.) with None in one or more specified columns.
    
    Parameters:
        df (pd.DataFrame): Input DataFrame.
        columns (str or list of str): Column name or list of column names to process.
    
    Returns:
        pd.DataFrame: DataFrame with missing values in the specified column(s) replaced by None.
    """
    # Normalize input to always be a list
    if isinstance(columns, str):
        columns = [columns]
    elif not isinstance(columns, (list, tuple)):
        raise ValueError("`columns` must be a string or a list/tuple of strings.")
    
    # Validate that all columns exist
    missing_cols = [col for col in columns if col not in df.columns]
    if missing_cols:
        raise ValueError(f"Column(s) not found in DataFrame: {missing_cols}")
    
    # Work on a copy to avoid modifying the original DataFrame
    df = df.copy()
    
    # Replace missing values with None in each specified column
    for col in columns:
        df[col] = df[col].where(pd.notna(df[col]), None)
    
    return df

def impute_merchant(df,column_name):
  df = df.copy()
  df[column_name] = df[column_name].fillna(df[column_name].mode()[0])
  return df

def cleaning(df):
  df = df.copy()
  print("Removing whitespace .....")
  df = remove_whitespace(df)
  print("Whitespace removed")
  print("Normalizing date to YYYY-MM-DD ......")
  df = normalize_date(df,"transaction_date")
  df = normalize_date(df,"value_date")
  print("Date normalized to YYYY-MM-DD")
  print("Replacing missing numeric value with None .....")
  df = replace_missing_with_none(df, ["amount","risk_score"])
  print("Missing numeric value replaced with None .....")
  df = impute_merchant(df,"merchant_category")
  print("Impute merchant category")
  
  return df

def load_csv(path: str) -> list[dict]:
  df = pd.read_csv(path)

  # Mandatory columns
  mandatory_columns = ["transaction_id","transaction_date","customer_id","account_id","amount","currency"]

  print("Checking empty row and missing column\n")

  # Check is row empty or mandatory columns missing
  for idx in df.index:
    if (df.loc[idx, df.columns[1:]].isnull().all() == True):
      print(f'Transaction with id {df.loc[idx, df.columns[0]]} is empty')
    elif (df.loc[idx, mandatory_columns].isnull().any() == True):
      print(f'Transaction with id {df.loc[idx, df.columns[0]]} missing mandatory columns')

  print("\nValidating Data\n")

  data_validation(df)
  print("\nValidation Completed")
  print("\nCleaning Data\n")
  df = cleaning(df)
  print("\nCleaning Completed\n")
  print("Transform data\n")
  df = transform(df)
  print("Data transformed\n")
  # Return dictionary
  list_of_dicts = df.to_dict(orient='records')
  return list_of_dicts

def date_conversion(df,column_name):
  df = df.copy()
  #df = normalize_date(df,column_name)
  df[column_name] = pd.to_datetime(df[column_name]).dt.date
  return df

def convert_to_float(df,column_name):
  df = df.copy()
  df[column_name] = df[column_name].astype('float64')
  return df

def derived_feature(df):
  df = df.copy()

  df['is_large_transaction'] = pd.NA
  df['is_crossborder'] = pd.NA
  df['transaction_day'] = pd.NA
  for idx in df.index:
    if df.loc[idx,"amount"] > 5000000 and isinstance(df.loc[idx,"amount"],float):
      df.loc[idx,'is_large_transaction'] = True
    else:
      df.loc[idx,'is_large_transaction'] = False

    if df.loc[idx,"currency"] != 'IDR' and isinstance(df.loc[idx,"currency"],str):
      df.loc[idx,'is_crossborder'] = True
    else:
      df.loc[idx,'is_crossborder'] = False
    try:
      df.loc[idx,'transaction_day'] = df.loc[idx,'transaction_date'].strftime("%A")
    except ValueError:
      continue
    
  return df

def transform(df):
  df = df.copy()
  print("Transforming date ....")
  df = date_conversion(df,"transaction_date")
  df = date_conversion(df,"value_date")
  print("Date transformed into datetime.date ....")
  print("converting numeric value datatype into float")
  df = convert_to_float(df,"amount")
  df = convert_to_float(df,"risk_score")
  print("Numeric value datatype converted into float")
  print("deriving feature")
  df = derived_feature(df)
  return df

def check_txn_pattern_regex(text):
    """Check if string matches TXN followed by exactly 7 digits"""
    pattern = r'^TXN\d{7}$'
    return bool(re.match(pattern, text))

def validate_date_format(date_string):
    """
    Validate if date string is in YYYY-MM-DD or DD/MM/YYYY format
    Returns: (is_valid, format_type, datetime_object)
    """
    if not isinstance(date_string, str):
        return False,False

    # Pattern for YYYY-MM-DD
    iso_pattern = r'^\d{4}-\d{2}-\d{2}$'

    # Pattern for DD/MM/YYYY
    eu_pattern = r'^\d{2}/\d{2}/\d{4}$'
    if date_string == "":
      return False,False
    elif re.match(iso_pattern, date_string):
      return True,False
    elif re.match(eu_pattern, date_string):
        return True,True
    else:
        return False,False

def amount_val(amount):
  return (0 < amount <= 10000000)

def currency_val(currency):
  return currency in ["IDR", "USD", "SGD"]

def direction_val(direction):
  return direction in ["DEBIT", "CREDIT"]

def account_type_val(account_type):
  return account_type in ["SAVINGS", "CURRENT", "CREDIT_CARD", "LOAN"]

def data_validation(df):
  for idx in df.index:

    # transaction_id wajib mengikuti pola: TXNxxxxxxx
    if (check_txn_pattern_regex(df.loc[idx,"transaction_id"]) == False):
      print(f'for id {df.loc[idx, df.columns[0]]} transaction id is invalid must use pattern TXNxxxxxxx')

    # Tanggal harus valid (deteksi format YYYY-MM-DD dan DD/MM/YYYY)
    if (validate_date_format(df.loc[idx,"transaction_date"])[0] == False):
      print(f'for id {df.loc[idx, df.columns[0]]} transaction date is invalid must use pattern YYYY-MM-DD or DD/MM/YYYY')

    if (validate_date_format(df.loc[idx,"value_date"])[0] == False):
      print(f'for id {df.loc[idx, df.columns[0]]} value date is invalid must use pattern YYYY-MM-DD or DD/MM/YYYY')

    # amount tidak boleh: bernilai negatif, kosong, dan lebih besar dari 10.000.000 IDR (flag anomaly)
    if amount_val(df.loc[idx, "amount"]) == False:
      print(f'for id {df.loc[idx, df.columns[0]]} amount is invalid must not negative, zero, and bigger than 10.000.000 IDR')

    # currency harus salah satu dari: IDR, USD, dan SGD
    if currency_val(df.loc[idx, "currency"]) == False:
      print(f'for id {df.loc[idx, df.columns[0]]} currency is invalid must use IDR, USD or SGD')

    # direction harus DEBIT atau CREDIT
    if direction_val(df.loc[idx, "direction"]) == False:
      print(f'for id {df.loc[idx, df.columns[0]]} direction is invalid must use DEBIT or CREDIT')

    # account_type harus salah satu dari: SAVINGS, CURRENT, CREDIT_CARD, LOAN
    if account_type_val(df.loc[idx, "account_type"]) == False:
      print(f'for id {df.loc[idx, df.columns[0]]} account type is invalid must use SAVINGS, CURRENT, CREDIT_CARD, or LOAN')

